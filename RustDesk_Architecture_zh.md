# RustDesk 全局架构

## 1. 概述

RustDesk 是一款主要用 Rust 编写的开源远程桌面软件。它提供了一种安全且可配置的方式来远程访问和控制设备。RustDesk 支持多个平台，并提供自托管、P2P 连接和端到端加密等功能。

## 2. 关键组件

RustDesk 的主要架构组件包括：

*   **核心逻辑 (Rust 后端):** 应用程序的核心，处理所有核心功能，如连接管理、数据流、安全性和平台交互。
*   **用户界面 (UI):** 使用 Flutter 构建，为桌面和移动应用程序提供跨平台的图形界面。
*   **集合服务器 (`hbbs`):** 一种可公开访问或自托管的服务器，可促进客户端之间的对等发现和连接启动。它帮助客户端找到彼此并穿透 NAT。
*   **中继服务器 (`hbbr`):** 当无法建立直接 P2P 连接时使用。它在控制设备和受控设备之间中继加密流量。
*   **平台抽象层:** Rust 核心内的一组模块，用于抽象特定于操作系统的功能，从而使核心逻辑在很大程度上保持平台无关性。
*   **HTTP API 服务器 (`hbbs` 的一部分):** 在使用商业版或自托管专业版时，提供用于用户帐户管理、设备同步和远程配置的 HTTP API。

## 3. 核心逻辑 (Rust 后端)

Rust 后端负责远程桌面操作的繁重工作。

*   **模块化:** 后端被组织成几个库 (crates)，以促进代码重用和关注点分离：
    *   `hbb_common`: 包含通用实用程序、数据结构 (protobuf 定义)、配置管理、TCP/UDP 包装器、用于文件传输的文件系统函数以及安全原语。
    *   `scrap`: 处理跨平台的屏幕捕获。
    *   `enigo`: 提供特定于平台的键盘和鼠标控制。
    *   `clipboard`: 为 Windows、Linux 和 macOS 实现文件复制和粘贴功能。
    *   其他较小的 crates，如 `virtual_display` 和 `remote_printer`，处理特定功能。

*   **主要应用程序入口点和进程角色:** `rustdesk` 可执行文件可以在几种模式下运行，具体取决于命令行参数：
    *   **默认 (客户端/主 UI):** 启动 Flutter UI，允许用户启动连接或接受传入连接。它还会启动一个后台服务器组件。
    *   **服务器 (`--server`):** 作为专用服务器进程运行，通常由操作系统服务管理。此进程处理传入的连接请求，管理活动会话，并提供视频、音频、输入和剪贴板共享等服务。
    *   **服务 (`--service`):** 管理主服务器进程，确保其在后台可靠运行。这对于无人值守访问至关重要。在 Linux 上，这还处理 X11/Wayland 会话管理。
    *   **命令行界面 (CLI) (各种标志，如 `--connect`、`--port-forward`):** 允许脚本编写和无头操作，如启动连接或设置端口转发。
    *   `src/main.rs` 和 `src/core_main.rs` 文件处理解析这些参数并将它们分派给适当的逻辑。`core_main.rs` 是 Sciter (已弃用) 和 Flutter UI 的共享入口点，在启动 UI 之前处理常见的初始化和参数解析。

*   **服务器端 (`src/server.rs`):**
    *   管理来自客户端的活动连接。
    *   向连接的客户端提供各种服务：
        *   **视频服务:** 捕获屏幕 (使用 `scrap`) 并将其流式传输到客户端。
        *   **音频服务:** 捕获和流式传输音频。
        *   **输入服务:** 从客户端接收输入事件 (鼠标、键盘) 并将其注入本地系统 (使用 `enigo`)。
        *   **剪贴板服务:** 在客户端和服务器之间同步剪贴板内容。
        *   **文件传输服务:** 促进文件传输操作。
    *   处理会话生命周期和安全性。

*   **客户端 (`src/client.rs`):**
    *   通过集合服务器或直接启动与远程对等方的连接。
    *   管理连接生命周期 (P2P、中继)。
    *   从服务器接收和呈现视频/音频流。
    *   捕获本地输入事件并将其发送到服务器。
    *   处理剪贴板同步。

## 4. 用户界面 (Flutter)

Flutter 框架用于桌面和移动平台上的面向客户端的 UI。

*   **结构:**
    *   **主应用程序窗口:** 用户管理其连接、设置和查看其传入连接 ID 的主要界面。 (`flutter/lib/main.dart` 初始化此窗口)。
    *   **多窗口支持:** 对于活动的远程会话 (远程桌面、文件传输、端口转发、查看摄像头)，RustDesk 利用 Flutter 的 `desktop_multi_window` 插件为每个会话创建单独的窗口。这允许同时管理多个远程会话。
    *   定义了不同的窗口类型 (`WindowType.RemoteDesktop`、`WindowType.FileTransfer` 等) 来处理特定的会话 UI。

*   **与 Rust 后端通信:**
    *   Flutter UI 通过 **外部函数接口 (FFI)** 与 Rust 核心逻辑通信。
    *   `flutter_rust_bridge` 用于生成 FFI 的样板代码，从而简化 Dart (Flutter) 和 Rust 之间的交互。
    *   `flutter/lib/models/platform_model.dart` 和生成的 `bridge_generated.dart` (隐含) 是此通信的关键，允许 Flutter 调用 Rust 函数并从 Rust 后端接收事件/数据。

*   **状态管理:** 虽然在提供的文件中没有明确详细说明，但 Flutter 应用程序通常使用 Provider、BLoC、GetX 或 Riverpod 等状态管理解决方案。`flutter/lib/common.dart` 和各个页面/小部件状态可能管理 UI 状态、对等列表、连接状态等。在 `flutter/lib/main.dart` 中可以看到 `GetX` (`get/get.dart`)，表明它用于路由和潜在的状态管理。

## 5. 平台抽象

RustDesk 设计为跨平台的，这是通过平台抽象层实现的。

*   **`src/platform/` 目录:** 此目录包含特定于操作系统的模块 (例如，`linux.rs`、`windows.rs`、`macos.rs`)。每个模块实现核心逻辑所需的平台相关功能。
*   **处理的功能:**
    *   **显示管理:** 枚举显示器、捕获屏幕内容 (与 `scrap` 的平台特定功能交互)、处理显示分辨率。
    *   **输入处理:** 捕获和注入键盘/鼠标事件 (与 `enigo` 的平台特定功能交互)。
    *   **服务管理:** 在不同操作系统上安装、启动、停止和卸载 RustDesk 后台服务。
    *   **剪贴板集成:** 访问和操作系​​统剪贴板。
    *   **音频输入/输出:** 与系统音频 API 交互。
    *   **权限:** 处理特定于操作系统的权限请求 (例如，屏幕录制、辅助功能)。
    *   **网络配置:** 检索网络接口信息、NAT 类型检测。
    *   **唤醒锁 (WakeLock):** `src/platform/mod.rs` 定义了一个 `WakeLock` 结构，以防止系统在活动会话期间进入睡眠状态，并具有特定于平台的实现。
    *   `src/platform/linux.rs` 显示了对 X11 和 Wayland 显示服务器、PulseAudio 和 systemd 服务管理的详细处理。

## 6. 网络和通信

RustDesk 采用复杂的网络模型在对等方之间建立连接。

*   **集合机制 (`src/rendezvous_mediator.rs`):**
    *   客户端向集合服务器 (`hbbs`) 注册其 ID 和网络信息 (公共 IP、NAT 类型)。
    *   当客户端想要连接到对等方时，它会向集合服务器查询对等方的信息。
    *   集合服务器促进初始握手并帮助进行 NAT 穿透。
    *   RustDesk 可以使用公共集合服务器或自托管的 `hbbs` 实例。
    *   Rust 中的 `RendezvousMediator` 处理与集合服务器的通信、注册和对等发现。

*   **连接建立:** RustDesk 按以下顺序尝试连接：
    1.  **直接局域网连接:** 如果两个对等方都在同一个本地网络中，则尝试直接 TCP 连接。
    2.  **P2P (UDP/TCP 打孔):** 如果对等方位于 NAT 之后，集合服务器会协助执行 UDP 打孔以建立直接 P2P 连接。也可能会尝试 TCP 打孔。
    3.  **中继连接:** 如果直接 P2P 连接失败 (例如，由于对称 NAT)，则通过 `hbbr` 服务器中继连接。流量仍然是端到端加密的。

*   **安全性:**
    *   **公钥注册:** 客户端向集合服务器注册其公钥。这有助于对对等方进行身份验证。
    *   **会话加密:** 所有会话数据都使用端到端加密。可能会使用 NaCl (网络和加密库) `box` (非对称加密) 和 `sign` (数字签名) 原语，如 `Cargo.toml` 中的 `sodiumoxide` 所示。初始握手涉及交换密钥以建立安全通道。
    *   密码和令牌用于身份验证。

*   **协议:**
    *   **Protobuf:** 用于定义与集合服务器交换以及在会话设置期间 (例如，`RendezvousMessage`、`VideoFrame`) 的消息结构。
    *   **UDP:** 主要用于 P2P 打孔，并可能用于在 P2P 会话中流式传输媒体数据。
    *   **TCP:** 用于直接局域网连接、中继连接以及在 UDP 失败或使用 WebSocket 时与集合服务器通信。
    *   **WebSockets (WS):** 可用作集合和中继通信的传输方式，尤其适用于绕过防火墙或在 Nginx 等反向代理后面运行 `hbbs`/`hbbr` 时。`src/rendezvous_mediator.rs` 中的 `use_ws()` 函数表明了此功能。

*   **HTTP API 通信 (`src/hbbs_http.rs`):**
    *   此组件处理与 `hbbs` HTTP API 服务器的通信。
    *   它用于用户身份验证、管理设备列表、同步配置以及可能用于专业版中的许可证管理等功能。
    *   它使用 `reqwest` crate 发出 HTTP 请求。

## 7. 构建和打包

*   **Cargo 工作区:** `Cargo.toml` 定义了一个工作区，其成员包括 `libs/scrap`、`libs/hbb_common` 等。这有助于在同一个项目中管理多个相关的 Rust crates。
*   **特定于平台的构建工具:** 虽然在提供的文件中没有明确详细说明，但特定于平台的代码和依赖项 (例如，Windows 的 `winapi`、Linux 的 X11/Wayland 库) 的存在意味着构建过程会处理这些差异。Flutter 也有自己的构建系统，用于为各种平台打包 UI。
*   **功能标志:** `Cargo.toml` 使用功能标志 (例如，`flutter`、`hwcodec`、`wayland`) 在编译期间启用或禁用特定功能，从而允许进行定制构建。

## 8. 关键区别

*   **自托管:** 该架构明确支持集合 (`hbbs`) 和中继 (`hbbr`) 服务器的自托管，从而使用户可以完全控制其数据和基础设施。
*   **跨平台:** Rust 核心与平台抽象层和 Flutter UI 的结合使 RustDesk 具有固有的跨平台性。
*   **安全焦点:** 端到端加密和公钥加密是设计的组成部分。
*   **模块化:** Rust 后端的基于库的结构可以提高可维护性并可能重用组件。
